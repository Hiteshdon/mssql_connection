<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Unicode Transformation Format: UTF-8</title><link rel="stylesheet" type="text/css" href="userguide.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="home" href="index.html" title="FreeTDS User Guide" /><link rel="up" href="AboutUnicode.html" title="Appendix C. About Unicode, UCS-2, and UTF-8" /><link rel="prev" href="Unicodegoodbad.html" title="Unicode's Pluses and Minuses" /><link rel="next" href="UnicodeFreeTDS.html" title="Unicode and FreeTDS" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Unicode Transformation Format: UTF-8</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="Unicodegoodbad.html">Prev</a> </td><th width="60%" align="center">Appendix C. About Unicode, UCS-2, and UTF-8</th><td width="20%" align="right"> <a accesskey="n" href="UnicodeFreeTDS.html">Next</a></td></tr></table><hr /></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="UnicodeUtf"></a>Unicode Transformation Format: UTF-8</h2></div></div></div><p>The presence of nulls embedded in character data and of byte order issues make straight Unicode i.e., UCS-2 or UCS-4 hard to work with in a heterogeneous environment.  Too many opportunities arise for the data to be truncated or misinterpreted, and too many systems would fail even to transmit such data.  In short, when 16-bit data are thrust into a multi-architecture 8-bit world, it frequently bodes ill for the data.</p><p>To answer that problem, to make Unicode transmissible and unambiguous to most machines, several <span class="quote">“<span class="quote">transformation formats</span>”</span> were adopted.  Their goals were generally similar: to create a generally recognized format that would unambiguously and safely convey Unicode information between machines and across the Internet.  To do that, they sought to remove nulls and endianism from the data stream.  The most popular one — practically the only one used — is known as UTF-8.</p><p>UTF-8 found wide acceptance for many reasons.  UTF-8 represents any Unicode character as a combination of 1-4 bytes.  The number of bytes required depends on the integer value of the Unicode character, and only one byte is used to represent the old <acronym class="acronym">ASCII</acronym> range (0-127).  UTF-8 does not use zero to represent any part of any character (except for the <acronym class="acronym">ASCII</acronym> NUL).  In consequence, UTF-8 is efficient with respect to space, has no endianism issues, and embeds no nulls.  UTF-8 strings can be treated as plain old <acronym class="acronym">ASCII</acronym> strings.  These properties make UTF-8 data relatively easy for systems accustomed to processing <acronym class="acronym">ASCII</acronym> data.</p><p>Here's a small example showing the difference between UCS-2 and UTF-8.
			</p><div class="example"><a id="e.g.HELLO"></a><p class="title"><strong>Example C.1. <span class="quote">“<span class="quote">HELLO</span>”</span> in UCS-2 and UTF-8</strong></p><div class="example-contents"><pre class="screen">
	$ <strong class="userinput"><code>echo HELLO | iconv -f ascii -t UCS-2 | hexdump -C</code></strong>
	00000000  00 48 00 45 00 4c 00 4c  00 4f 00 0a              |.H.E.L.L.O..|
	0000000c
	$ <strong class="userinput"><code>echo HELLO | iconv -f ascii -t utf-8 | hexdump -C</code></strong>
	00000000  48 45 4c 4c 4f 0a                                 |HELLO.|
	00000006
	$ <strong class="userinput"><code>echo HELLO | hexdump -C</code></strong>
	00000000  48 45 4c 4c 4f 0a                                 |HELLO.|
	00000006</pre></div></div><p><br class="example-break" />
	It is the similarity of the last two outputs that makes UTF-8 so attractive.  It behaves like <acronym class="acronym">ASCII</acronym> when <acronym class="acronym">ASCII</acronym>'s all that's needed.  But it lacks <acronym class="acronym">ASCII</acronym>'s limitations.</p><p>While UTF-8 solves many technical problems, it doesn't magically transform every <acronym class="acronym">ASCII</acronym>-assuming system into a Unicode system.  For example, to display Unicode data correctly — even Unicode data in UTF-8 format — the system still needs a suitable font.  And it must distinguish the buffer size (and byte count) from the character count.</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="Unicodegoodbad.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="AboutUnicode.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="UnicodeFreeTDS.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Unicode's Pluses and Minuses </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Unicode and <span class="productname">FreeTDS</span></td></tr></table></div></body></html>